<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Visualiseur Audio 3D Sph√©rique</title>
  <style>
    body { margin: 0; background: #000; color: #fff; font-family: sans-serif; }
    #controls { position: absolute; top: 10px; left: 10px; z-index: 10; background: #111; padding: 10px; border-radius: 5px; }
    #shaderEditor { width: 100%; height: 200px; font-family: monospace; font-size: 12px; background: #222; color: #0f0; border: none; }
    canvas { display: block; }
    button, input { margin: 5px 0; }
  </style>
</head>
<body>

<div id="controls">
  <input type="file" id="audioFile" accept="audio/*"><br>
  <input type="file" id="shaderFile" accept=".shader"><br>
  <button id="playPause">Play/Pause</button>
  <button id="export">Exporter MP4</button><br>
  <label>Shader Editor (vertex + fragment):</label><br>
  <textarea id="shaderEditor"></textarea>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ccapture.js/1.1.0/CCapture.all.min.js"></script>

<script>
  let scene, camera, renderer, sphere, material, audio, analyser, dataArray;
  let isPlaying = false;
  let capturer = null;
  let exportMode = false;

  const defaultShader = `
// Vertex Shader
uniform float time;
uniform float bass;
varying vec3 vNormal;
void main() {
  vNormal = normal;
  float amp = bass * 0.5;
  vec3 newPos = position + normal * sin(time + position.y * 5.0) * amp;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
}

---

// Fragment Shader
uniform float time;
uniform float mid;
varying vec3 vNormal;
void main() {
  float color = sin(time + vNormal.x * 10.0) * mid;
  gl_FragColor = vec4(color, color * 0.5, 1.0 - color, 1.0);
}
`;

  document.getElementById('shaderEditor').value = defaultShader;

  function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const geometry = new THREE.SphereGeometry(2, 128, 128);
    material = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0 },
        bass: { value: 0 },
        mid: { value: 0 }
      },
      vertexShader: defaultShader.split('---')[0].replace('// Vertex Shader', ''),
      fragmentShader: defaultShader.split('---')[1].replace('// Fragment Shader', ''),
      side: THREE.DoubleSide
    });
    sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);

    const listener = new THREE.AudioListener();
    camera.add(listener);
    audio = new THREE.Audio(listener);

    analyser = new THREE.AudioAnalyser(audio, 512);

    animate();
  }

  function updateShader() {
    const src = document.getElementById('shaderEditor').value;
    const parts = src.split('---');
    try {
      material.vertexShader = parts[0].replace('// Vertex Shader', '');
      material.fragmentShader = parts[1].replace('// Fragment Shader', '');
      material.needsUpdate = true;
    } catch (e) {
      console.warn("Erreur de compilation shader", e);
    }
  }

  document.getElementById('shaderEditor').addEventListener('input', updateShader);

  document.getElementById('audioFile').addEventListener('change', function (e) {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    audio.setBuffer(null);
    const loader = new THREE.AudioLoader();
    loader.load(url, function (buffer) {
      audio.setBuffer(buffer);
    });
  });

  document.getElementById('shaderFile').addEventListener('change', function (e) {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function (evt) {
      document.getElementById('shaderEditor').value = evt.target.result;
      updateShader();
    };
    reader.readAsText(file);
  });

  document.getElementById('playPause').addEventListener('click', function () {
    if (!audio.buffer) return;
    if (audio.isPlaying) {
      audio.pause();
    } else {
      audio.play();
    }
  });

  document.getElementById('export').addEventListener('click', function () {
    if (!audio.buffer) return;
    exportMode = true;
    capturer = new CCapture({
      format: 'webm',
      framerate: 30,
      verbose: true
    });
    capturer.start();
    audio.stop();
    audio.play();
  });

  function animate() {
    requestAnimationFrame(animate);

    if (analyser) {
      const data = analyser.getFrequencyData();
      const bass = data.slice(0, 32).reduce((a, b) => a + b) / 32 / 255;
      const mid = data.slice(32, 128).reduce((a, b) => a + b) / 96 / 255;

      material.uniforms.time.value += 0.01;
      material.uniforms.bass.value = bass;
      material.uniforms.mid.value = mid;
    }

    renderer.render(scene, camera);

    if (exportMode && capturer) {
      capturer.capture(renderer.domElement);
      if (!audio.isPlaying) {
        capturer.stop();
        capturer.save();
        exportMode = false;
      }
    }
  }

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  init();
</script>

</body>
</html>
